/*
 *   Shikai Jin 
 *   sjin02@syr.edu
 *   SUID 844973756
 */
/*
 * Manual Page:
 * 
 * class RuleTester
 * RuleTester rt=new RuleTester();
 * rt.AddRule(arule);               //add a rule 
 * rt.Test(ex);                     //ex should be a SemiExtractor. All semis generated by ex will be tested.
 * rt.TestRuleTree(arule,asemi)     //use arule and its children to test asemi    
 * 
 * class Parser
 * Parser pa=new Parser();
 * pa.Parse(filename,pattern,isrecursive) //parse the files specified by filename and pattern, 
 *                                        //if isrecursive is true, it will search all subordinate folders
 * 
 * 
 * Maintenance History:
 * Ver 1.0  Oct. 4  2014 
 * created by Shikai Jin 
 * 
 * Ver 2.0 Oct. 9
 * FileHeaderInfo Added to track the namespace and filename info
 */
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CodeAnalyzer
{
    //Record namespace and current searched file 
    public class FileHeaderInfo
    {
        static List<string> _namespace=new List<string>();
        public static List<string> UsingNamespace
        {
            get { return _namespace; }
        }
        public static string FileName = "";

    };
    /*
     * Test the rule tree for each semiexpression
     * if a semi passes a rule, it will go to its subrules
     * otherwise, it will not.
     */
    public class RuleTester
    {
        public void Test(SemiExtractor ex)
        {
            FileHeaderInfo.FileName = ex.FileName;
            FileHeaderInfo.UsingNamespace.Clear();
            bool begintorecordnamespace = true;
            try
            {
                while (true)
                {
                    SemiExpression se = ex.GetNextSemi();
                    if (begintorecordnamespace)
                    {
                        int usingindex = se.FindFirstToken("using");
                        int colonindex = se.FindFirstToken(";");
                        int braceindex = se.FindFirstToken("{");
                        if (usingindex != -1 && colonindex != -1 && usingindex < colonindex)
                        {
                            string namespacestr="";
                            for (int i = usingindex + 1; i < colonindex; i++)
                            {
                                namespacestr += se[i];
                            }
                            FileHeaderInfo.UsingNamespace.Add(namespacestr);
                        }
                        if (braceindex != -1)
                            begintorecordnamespace = false;
                    }
                    if (se == null)
                        break;
                    TestRuleTree(Root_Rule, se);
                }
            }
            catch (Exception exc)
            {
                Console.Write("\n\n  {0}\n", exc.Message);
            }
        }
        /*
         * recursively test all the rules in the rule tree
         * and run the related action
         *   
         */
        public bool TestRuleTree(BaseRule rule, SemiExpression se)
        {
            if (false == rule.Test(se))
            {
                return false;
            }
            else
            {
                foreach (BaseAction action in rule.Action)
                {
                    action.Do(rule.Arg);
                }
                foreach (BaseRule r in rule.ChildRule)
                {
                    bool f=TestRuleTree(r, se);
                    if (rule.IsSubruleExclusive==true && f == true)
                    {
                        break;
                    }
                }
                return true;
            }
        }
        /*
         * add a rule to the root rule
         * root rule is just a place holder that always returns true
         *   
         */
        public void AddRule(BaseRule rule)
        {
            Root_Rule.AddSubrule(rule);
        }
        TrueRule Root_Rule = new TrueRule();
    }
    /*
     * Subscriber of the navigate
     * when navigate goes through a certain file set
     * it will use RuleTester to parse each file
     *   
     */
    public class Parser
    {
        RuleTester _ruletester = new RuleTester();
        //constructor to subscribe to the navigate
        public Parser()
        {
            _ruletester.AddRule(RuleMaker.Make());
            Navigate.Instance.OnFileFound += ParseOneFile;
        }
        //parse all the file given by the path and pattern
        public void Parse(string path,string pattern,bool isrec=false)
        {
            Navigate.Instance.Go(path, pattern, isrec);
        }
        //callback function that parse a specific file
        void ParseOneFile(string filename)
        {
            SemiExtractor ex = new SemiExtractor();

            if (false == ex.Open(filename))
                return;


            _ruletester.Test(ex);
        }
    }
    //Test Stub
#if(TEST_PARSER)
    class TestP
    {
        static void Main(string[] args)
        {
            Parser p = new Parser();
            p.Parse("../../", "Semi.cs");
            OutputManager.DisplayTypes(TypeRepository.Instance.RootScope);
            System.Console.ReadLine();
        }
    }
#endif
}
